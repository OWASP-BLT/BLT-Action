const core = require('@actions/core');
const github = require('@actions/github');
const axios = require('axios');

async function hasOpenLinkedPR(
    octokit,
    owner,
    repoName,
    issueNumber,
    returnDetails = false
) {
    const openPRs = [];
    const currentRepo = `${owner}/${repoName}`;
    const seen = new Set();

    const timelineEvents = await octokit.paginate(
        octokit.issues.listEventsForTimeline,
        { owner, repo: repoName, issue_number: issueNumber, per_page: 100, headers: { accept: 'application/vnd.github+json','X-GitHub-Api-Version': '2022-11-28' } }
    );

    for (const e of timelineEvents) {
        if (e.event !== "cross-referenced" || !e.source?.issue?.pull_request) {
            continue;
        }

        const prNumber = e.source?.issue?.number;

        // Ensure the PR belongs to the same repository
        const sourceRepo = e.source?.repository?.full_name;
        if (sourceRepo !== currentRepo) continue; // skip if undefined or different
        if (!prNumber || seen.has(prNumber)) continue;
        seen.add(prNumber);

        try {
            const pr = await octokit.pulls.get({
                owner,
                repo: repoName,
                pull_number: prNumber
            });

            if (pr.data.state === "open") {
                if (returnDetails) {
                    openPRs.push(pr.data);
                } else {
                    return true; // short-circuit for boolean use case
                }
            }
        } catch (err) {
            // 404 = PR deleted; safe to skip. 
            if (err.status !== 404) {
                console.error(`Error fetching PR #${prNumber}:`, err?.status || err?.message || 'unknown error');
            }
            console.log(
                `Skipping linked PR #${prNumber}: ${err?.status || err?.message || 'unknown error'}`
            );
            continue;
        }
    }

    return returnDetails ? openPRs : false;
}

const run = async () => {
    try {
        console.log("Starting GitHub Action...");

        // Get necessary inputs
        const gitHubToken = core.getInput('repo-token', { required: true });
        const giphyApiKey = core.getInput('giphy-api-key', { required: true });
        const octokit = github.getOctokit(gitHubToken);

        const { eventName, payload, repo } = github.context;
        const { issue, comment, pull_request } = payload;
        const repository = `${repo.owner}/${repo.repo}`;
        const [owner, repoName] = repository.split('/');

        console.log(`Processing event: ${eventName} in repository ${repository}`);

        // Attribution footer for all comments
        const attribution = '\n\n---\n*This comment was generated by [OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)*';

        // Assignment keywords
        const assignKeywords = ['/assign', 'assign to me', 'assign this to me', 'assign it to me', 'assign me this', 'work on this', 'i can try fixing this', 'i am interested in doing this', 'be assigned this', 'i am interested in contributing'];
        const unassignKeywords = ['/unassign'];
        const giphyKeyword = '/giphy';
        const kudosKeyword = '/kudos';
        const tipKeyword = '/tip';

        if ((eventName === 'issue_comment' && issue && comment) || (eventName === 'pull_request_review_comment' && pull_request && comment)) {
            console.log('Processing comment...');
            const commentBody = comment.body.toLowerCase();
            const shouldAssign = assignKeywords.some(keyword => commentBody.includes(keyword));
            const shouldUnassign = unassignKeywords.some(keyword => commentBody.startsWith(keyword));
            const shouldGiphy = commentBody.startsWith(giphyKeyword);
            const shouldKudos = commentBody.startsWith(kudosKeyword);
            const shouldTip = commentBody.startsWith(tipKeyword);

            if (shouldUnassign) {
                console.log(`Unassigning issue #${issue.number} from ${comment.user.login}`);

                try {
                    // Fetch issue details
                    const issueDetails = await octokit.issues.get({
                        owner,
                        repo: repoName,
                        issue_number: issue.number
                    });

                    const hasAssignedLabel = issueDetails.data.labels.some(label => label.name === "assigned");

                    if (hasAssignedLabel) {
                        await octokit.issues.removeAssignees({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            assignees: [comment.user.login]
                        });

                        await octokit.issues.removeLabel({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            name: "assigned"
                        }).catch(() => console.log("Label already removed or not found."));

                        // Check existing comments to avoid duplicates
                        const existingComments = await octokit.issues.listComments({
                            owner,
                            repo: repoName,
                            issue_number: issue.number
                        });

                        const unassignMessageExists = existingComments.data.some(comment =>
                            comment.body.includes('‚è∞ This issue has been automatically unassigned from') ||
                            comment.body.includes('You have been unassigned from this issue.')
                        );

                        if (!unassignMessageExists) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue.number,
                                body: `You have been unassigned from this issue. It's now open for others. You can reassign it anytime by typing \`/assign\`.${attribution}`
                            });
                        }
                    } else {
                        console.log(`Issue #${issue.number} does not have the "assigned" label, skipping unassign.`);
                    }
                } catch (error) {
                    console.error(`Error unassigning issue #${issue.number}:`, error);
                }
            }

            if (shouldAssign) {
                try {
                    if (!issue) {
                        console.log('Skipping /assign: no issue context for this event.');
                        // Skip assignment but continue with other processing
                    } else {
                        console.log(`Assigning issue #${issue.number} to ${comment.user.login}`);
                        const assigneeLogin = comment.user.login;

                        // Check if there's already an open PR linked to this issue using timeline events
                        console.log(`Checking for open PRs linked to issue #${issue.number}`);
                        const linkedOpenPRs = await hasOpenLinkedPR(octokit, owner, repoName, issue.number, true);

                        if (linkedOpenPRs.length > 0) {
                            console.log(`Found ${linkedOpenPRs.length} open PR(s) linked to issue #${issue.number}`);

                            // Get PR details
                            const prList = linkedOpenPRs.map(pr => {
                                const prAge = Math.floor((new Date() - new Date(pr.created_at)) / (1000 * 3600 * 24));
                                const author = pr.user?.login ? `@${pr.user.login}` : '[deleted user]';
                                return `- #${pr.number} by ${author} (${prAge} days old)`;
                            });

                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue.number,
                                body: `**This issue already has open pull request(s) linked to it:**\n\n${prList.join('\n')}\n\nPlease verify with the PR author(s) regarding the status of these pull requests before taking over this issue.\n\n**Next Steps:**\n- If the existing PR(s) are stale or abandoned, coordinate with the PR author(s) and maintainers\n- After coordination, a maintainer can manually assign this issue if appropriate\n- Consider collaborating with the existing PR author(s) instead of duplicating work${attribution}`
                            });
                            return; // Stop here - assignment blocked
                        }

                        // Get assigned issues
                        const assignedIssues = await octokit.paginate(octokit.issues.listForRepo, {
                            owner,
                            repo: repoName,
                            state: 'open',
                            assignee: assigneeLogin
                        });

                        // Check if user has unresolved issues without a PR
                        let issuesWithoutPR = [];
                        for (const assignedIssue of assignedIssues) {
                            if (assignedIssue.number === issue.number) continue;

                            // Use the correct helper function instead of search API
                            if (!(await hasOpenLinkedPR(octokit, owner, repoName, assignedIssue.number))) {
                                console.log(`Issue #${assignedIssue.number} does not have an open pull request`);
                                issuesWithoutPR.push(assignedIssue.number);
                            }
                        }

                        if (issuesWithoutPR.length > 0) {
                            const issueList = issuesWithoutPR.join(', #');
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue.number,
                                body: `You cannot be assigned to this issue because you are already assigned to the following issues without an open pull request: #${issueList}. Please submit a pull request for these issues before getting assigned to a new one.${attribution}`
                            });
                            return; // Stop here - assignment blocked
                        }

                        // prevent multiple assignees
                        const currentAssignees = issue.assignees || [];

                        if (currentAssignees.length > 0) {
                            const currentAssignee = currentAssignees[0].login;

                            if (currentAssignee !== assigneeLogin) {
                                console.log(`Issue #${issue.number} is already assigned to ${currentAssignee}`);

                                await octokit.issues.createComment({
                                    owner,
                                    repo: repoName,
                                    issue_number: issue.number,
                                    body: `‚ö†Ô∏è This issue is already assigned to @${currentAssignee}. Please pick another issue.`
                                });

                                return; // Stop here - assignment blocked
                            }

                            // If already assigned to the same user ‚Üí proceed silently
                            console.log(`Issue #${issue.number} is already assigned to ${assigneeLogin}. Skipping redundant assignment`);
                            return; // Stop here - nothing to do
                        }

                        // Assign user to the issue
                        await octokit.issues.addAssignees({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            assignees: [assigneeLogin]
                        });

                        // Add "assigned" label
                        await octokit.issues.addLabels({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            labels: ["assigned"]
                        });

                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            body: `Hello @${assigneeLogin}! You've been assigned to [${repository} issue #${issue.number}](https://github.com/${repository}/issues/${issue.number}). You have 24 hours to complete a pull request.${attribution}`
                        });
                    }

                } catch (error) {
                    console.error(`Error assigning issue #${issue.number}:`, error);
                }
            } else if (shouldGiphy) {
                const searchText = commentBody.replace(giphyKeyword, '').trim();
                const giphyResponse = await axios.get(`https://api.giphy.com/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`);
                const gifUrl = giphyResponse.data.data[0]?.images?.original?.url;

                if (gifUrl) {
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `![Giphy GIF](${gifUrl})${attribution}`
                    });
                } else {
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `No GIFs found for "${searchText}".${attribution}`
                    });
                }
            } else if (shouldKudos) {
                const kudosCommand = comment.body.trim().split(/\s+/);
                if (kudosCommand.length >= 2) {
                    const sender = comment.user.login; // GitHub username of the commenter
                    let receiver = kudosCommand[1]; // Receiver from the command
                    const kudosComment = kudosCommand.slice(2).join(' ') || 'Great work!'; // Optional comment

                    // Strip @ symbol from receiver if present
                    receiver = receiver.replace(/^@/, '');

                    // Build the link to the issue or PR where kudos was given
                    const issueNumber = issue ? issue.number : pull_request.number;
                    const link = `https://github.com/${owner}/${repoName}/issues/${issueNumber}`;

                    console.log(`Sending kudos from ${sender} to @${receiver} with comment: "${kudosComment}"`);

                    // Always post kudos comment on GitHub first
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issueNumber,
                        body: `üéâ Kudos from @${sender} to @${receiver}! üéâ\n\n> ${kudosComment}${attribution}`
                    });

                    // Try to send to BLT API (optional, won't fail if user doesn't have profile)
                    try {
                        await axios.post('https://owaspblt.org/teams/give-kudos/', {
                            kudosReceiver: receiver,
                            kudosSender: sender,
                            link: link,
                            comment: kudosComment
                        });

                        // If successful, add a follow-up comment about BLT tracking
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issueNumber,
                            body: `‚úÖ Kudos tracked on [BLT profile](https://owaspblt.org/profile/${receiver})!${attribution}`
                        });

                        console.log(`Kudos successfully tracked on BLT for ${receiver}`);
                    } catch (apiError) {
                        console.log(`Note: Kudos not tracked on BLT (user may not have a profile): ${apiError.message}`);

                        // Post informational message about BLT profile (only if it's a 404 or similar)
                        if (apiError.response && (apiError.response.status === 404 || apiError.response.status === 400)) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issueNumber,
                                body: `üí° @${receiver} - Create a [BLT profile](https://owaspblt.org) to track all your kudos in one place!${attribution}`
                            });
                        }
                    }
                } else {
                    console.log('Invalid /kudos command format.');
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `‚ö†Ô∏è Invalid /kudos command format.\n\nUsage: \`/kudos @username [optional comment]\`\n\nExample: \`/kudos @alice Great work on the PR!\`${attribution}`
                    });
                }
            } else if (shouldTip) {
                const tipCommand = comment.body.trim().split(/\s+/);
                if (tipCommand.length >= 3) {
                    const sender = comment.user.login; // GitHub username of the commenter
                    const receiver = tipCommand[1].replace('@', ''); // Remove @ if present
                    const amount = tipCommand[2]; // Amount with $ symbol

                    // Validate amount format
                    const amountMatch = amount.match(/^\$?(\d+(?:\.\d{1,2})?)$/);
                    if (!amountMatch) {
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issue ? issue.number : pull_request.number,
                            body: `‚ö†Ô∏è Invalid amount format. Use: \`/tip @username $amount\` (e.g., \`/tip @user $5\` or \`/tip @user $10.50\`)${attribution}`
                        });
                        return;
                    }

                    const amountValue = amountMatch[1];
                    const sponsorUrl = `https://github.com/sponsors/${receiver}`;

                    console.log(`Generating tip link from ${sender} to ${receiver} for $${amountValue}`);

                    try {
                        const sponsorCheckResponse = await axios.head(sponsorUrl, {
                            timeout: 8000,
                            validateStatus: () => true, // don't throw; we inspect status
                        });

                        if (sponsorCheckResponse.status === 404) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è @${receiver} does not appear to have GitHub Sponsors enabled. Please verify the username or ask them to set up GitHub Sponsors first.\n\nLearn more: https://github.com/sponsors${attribution}`
                            });
                            return;
                        }
                        if (sponsorCheckResponse.status >= 300 && sponsorCheckResponse.status < 400) {
                            // Redirects are typically followed by axios, but log if we see one
                            console.log(`Redirect status ${sponsorCheckResponse.status} for sponsor check - treating as success`);
                        }
                        else if (sponsorCheckResponse.status < 200 || sponsorCheckResponse.status >= 400) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è Could not verify GitHub Sponsors for @${receiver} right now (status ${sponsorCheckResponse.status}). Please try again later or visit ${sponsorUrl}.${attribution}`
                            });
                            return;
                        }

                        // Post success message with sponsor link
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issue ? issue.number : pull_request.number,
                            body: `üí∞ **Tip Request from @${sender} to @${receiver}**\n\n` +
                                `Amount: **$${amountValue}**\n\n` +
                                `To complete this tip, please visit @${receiver}'s GitHub Sponsors page and select a one-time payment:\n\n` +
                                `üîó [Sponsor @${receiver}](${sponsorUrl})\n\n` +
                                `*Note: GitHub Sponsors does not support automated payments via API. Please complete the transaction manually by selecting "One-time" on the sponsor page and entering your desired amount.*${attribution}`
                        });
                    } catch (error) {
                        console.error('Error processing tip command:', error);
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issue ? issue.number : pull_request.number,
                            body: `‚ö†Ô∏è Failed to process tip request. Please try again later or visit https://github.com/sponsors/${receiver} directly.${attribution}`
                        });
                    }
                } else {
                    console.log('Invalid /tip command format.');
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `‚ö†Ô∏è Invalid /tip command format. Use: \`/tip @username $amount\`\n\nExample: \`/tip @contributor $10\`${attribution}`
                    });
                }
            }
        }

        // Only run stale assignment checks on scheduled events
        if (eventName !== 'schedule') {
            console.log('Skipping stale assignment checks - not a scheduled event');
            return;
        }

        console.log('Checking for stale assignments...');
        const presentDate = new Date();

        try {
            const events = await octokit.paginate(octokit.issues.listEventsForRepo, {
                owner,
                repo: repoName,
                per_page: 100,
            }, response => response.data.filter(event => event.event === "assigned"));

            for (const event of events) {
                if (event.issue.assignee && event.issue.state === "open") {
                    const timeSinceUpdate = presentDate.getTime() - new Date(event.issue.updated_at).getTime();
                    const daysInactive = timeSinceUpdate / (1000 * 3600 * 24);

                    if (daysInactive > 1) {
                        console.log(`Unassigning issue #${event.issue.number} due to inactivity`);
                        try {
                            const hasOpenPR = await hasOpenLinkedPR(octokit, owner, repoName, event.issue.number);
                            if (hasOpenPR) {
                                console.log(`Issue #${event.issue.number} has an open pull request (cross-referenced), skipping unassign.`);
                                continue;
                            }
                        } catch (searchError) {
                            console.log(`Error checking for open pull requests for issue #${event.issue.number}:`, searchError);
                            console.log(`Skipping unassignment for issue #${event.issue.number} due to verification failure.`);
                            continue;
                        }

                        const issueDetails = await octokit.issues.get({
                            owner,
                            repo: repoName,
                            issue_number: event.issue.number
                        });

                        const hasAssignedLabel = issueDetails.data.labels.some(label => label.name === "assigned");

                        if (hasAssignedLabel) {
                            await octokit.issues.removeAssignees({
                                owner,
                                repo: repoName,
                                issue_number: event.issue.number,
                                assignees: [event.issue.assignee.login]
                            });

                            await octokit.issues.removeLabel({
                                owner,
                                repo: repoName,
                                issue_number: event.issue.number,
                                name: "assigned"
                            });

                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: event.issue.number,
                                body: `‚è∞ This issue has been automatically unassigned from @${event.issue.assignee.login} due to 24 hours of inactivity without an *open* linked pull request.\n\n**Next Steps:**\n1. If you were working on this, you can reassign it by typing \`/assign\`\n2. If you have a WIP pull request, please link it to this issue\n3. The issue is now available for others to work on\n\nNote: If there's an existing PR linked to this issue that needs attention, please coordinate with the PR author.${attribution}`
                            });
                        } else {
                            console.log(`Issue #${event.issue.number} does not have the "assigned" label, skipping unassign.`);
                        }
                    }
                }
            }
        } catch (error) {
            console.error("Error processing stale assignments:", error);
        }

    } catch (error) {
        console.error("Critical error in GitHub Action:", error);
    }
};

run();