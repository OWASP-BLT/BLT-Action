const core = require('@actions/core');
const github = require('@actions/github');
const axios = require('axios');

const run = async () => {
    try {
        console.log("Starting GitHub Action...");

        // Get necessary inputs
        const gitHubToken = core.getInput('repo-token', { required: true });
        const giphyApiKey = core.getInput('giphy-api-key', { required: true });
        const octokit = github.getOctokit(gitHubToken);

        const { eventName, payload, repo } = github.context;
        const { issue, comment, pull_request } = payload;
        const repository = `${repo.owner}/${repo.repo}`;
        const [owner, repoName] = repository.split('/');

        console.log(`Processing event: ${eventName} in repository ${repository}`);

        // Attribution footer for all comments
        const attribution = '\n\n---\n*This comment was generated by [OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)*';

        // Assignment keywords
        const assignKeywords = ['/assign', 'assign to me', 'assign this to me', 'assign it to me', 'assign me this', 'work on this', 'i can try fixing this', 'i am interested in doing this', 'be assigned this', 'i am interested in contributing'];
        const unassignKeywords = ['/unassign'];
        const giphyKeyword = '/giphy';
        const kudosKeyword = '/kudos';
        const tipKeyword = '/tip';

        if ((eventName === 'issue_comment' && issue && comment) || (eventName === 'pull_request_review_comment' && pull_request && comment)) {
            console.log('Processing comment...');
            const commentBody = comment.body.toLowerCase();
            const shouldAssign = assignKeywords.some(keyword => commentBody.includes(keyword));
            const shouldUnassign = unassignKeywords.some(keyword => commentBody.startsWith(keyword));
            const shouldGiphy = commentBody.startsWith(giphyKeyword);
            const shouldKudos = commentBody.startsWith(kudosKeyword);
            const shouldTip = commentBody.startsWith(tipKeyword);

            if (shouldUnassign) {
                console.log(`Unassigning issue #${issue.number} from ${comment.user.login}`);

                try {
                    // Fetch issue details
                    const issueDetails = await octokit.issues.get({
                        owner,
                        repo: repoName,
                        issue_number: issue.number
                    });

                    const hasAssignedLabel = issueDetails.data.labels.some(label => label.name === "assigned");

                    if (hasAssignedLabel) {
                        await octokit.issues.removeAssignees({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            assignees: [comment.user.login]
                        });

                        await octokit.issues.removeLabel({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            name: "assigned"
                        }).catch(() => console.log("Label already removed or not found."));

                        // Check existing comments to avoid duplicates
                        const existingComments = await octokit.issues.listComments({
                            owner,
                            repo: repoName,
                            issue_number: issue.number
                        });

                        const unassignMessageExists = existingComments.data.some(comment =>
                            comment.body.includes('‚è∞ This issue has been automatically unassigned from  due to 24 hours of inactivity.') ||
                            comment.body.includes('You have been unassigned from this issue.')
                        );

                        if (!unassignMessageExists) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue.number,
                                body: `You have been unassigned from this issue. It‚Äôs now open for others. You can reassign it anytime by typing /assign.${attribution}`
                            });
                        }
                    } else {
                        console.log(`Issue #${issue.number} does not have the "assigned" label, skipping unassign.`);
                    }
                } catch (error) {
                    console.error(`Error unassigning issue #${issue.number}:`, error);
                }
            }

            if (shouldAssign) {
                console.log(`Assigning issue #${issue.number} to ${comment.user.login}`);
                try {
                    const assigneeLogin = comment.user.login;

                    // Get assigned issues
                    const assignedIssues = await octokit.paginate(octokit.issues.listForRepo, {
                        owner,
                        repo: repoName,
                        state: 'open',
                        assignee: assigneeLogin
                    });

                    // Check if user has unresolved issues without a PR
                    let issuesWithoutPR = [];
                    for (const assignedIssue of assignedIssues) {
                        if (assignedIssue.number === issue.number) continue;

                        const query = `repo:${owner}/${repoName} is:pr is:open ${assignedIssue.number} in:body`;
                        const pullRequests = await octokit.search.issuesAndPullRequests({ q: query });

                        if (pullRequests.data.total_count === 0) {
                            console.log(`Issue #${assignedIssue.number} does not have an open pull request`);
                            issuesWithoutPR.push(assignedIssue.number);
                        }
                    }

                    if (issuesWithoutPR.length > 0) {
                        const issueList = issuesWithoutPR.join(', #');
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issue.number,
                            body: `You cannot be assigned to this issue because you are already assigned to the following issues without an open pull request: #${issueList}. Please submit a pull request for these issues before getting assigned to a new one.${attribution}`
                        });
                        return;
                    }

                    // prevent multiple assignees
                    const currentAssignees = issue.assignees || [];

                    if (currentAssignees.length > 0) {
                        const currentAssignee = currentAssignees[0].login;

                        if (currentAssignee !== assigneeLogin) {
                            console.log(`Issue #${issue.number} is already assigned to ${currentAssignee}`);

                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue.number,
                                body: `‚ö†Ô∏è This issue is already assigned to @${currentAssignee}. Please pick another issue.`
                            });

                            return; // prevent assignment
                        }

                        // If already assigned to the same user ‚Üí proceed silently
                        console.log(`Issue #${issue.number} is already assigned to ${assigneeLogin}. Skipping redundant assignment`);
                        return;
                    }

                    // Assign user to the issue
                    await octokit.issues.addAssignees({
                        owner,
                        repo: repoName,
                        issue_number: issue.number,
                        assignees: [assigneeLogin]
                    });

                    // Add "assigned" label
                    await octokit.issues.addLabels({
                        owner,
                        repo: repoName,
                        issue_number: issue.number,
                        labels: ["assigned"]
                    });

                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue.number,
                        body: `Hello @${assigneeLogin}! You've been assigned to [${repository} issue #${issue.number}](https://github.com/${repository}/issues/${issue.number}). You have 24 hours to complete a pull request.${attribution}`
                    });

                } catch (error) {
                    console.error(`Error assigning issue #${issue.number}:`, error);
                }
            } else if (shouldGiphy) {
                const searchText = commentBody.replace(giphyKeyword, '').trim();
                const giphyResponse = await axios.get(`https://api.giphy.com/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`);
                const gifUrl = giphyResponse.data.data[0]?.images?.original?.url;

                if (gifUrl) {
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `![Giphy GIF](${gifUrl})${attribution}`
                    });
                } else {
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `No GIFs found for "${searchText}".${attribution}`
                    });
                }
            } else if (shouldKudos) {
                const kudosCommand = comment.body.trim().split(/\s+/);
                if (kudosCommand.length >= 2) {
                    const sender = comment.user.login; // GitHub username of the commenter
                    let receiver = kudosCommand[1]; // Receiver from the command
                    const kudosComment = kudosCommand.slice(2).join(' ') || 'Great work!'; // Optional comment
                    
                    // Strip @ symbol from receiver if present
                    receiver = receiver.replace(/^@/, '');

                    // Build the link to the issue or PR where kudos was given
                    const issueNumber = issue ? issue.number : pull_request.number;
                    const link = `https://github.com/${owner}/${repoName}/issues/${issueNumber}`;

                    console.log(`Sending kudos from ${sender} to @${receiver} with comment: "${kudosComment}"`);

                    // Always post kudos comment on GitHub first
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issueNumber,
                        body: `üéâ Kudos from @${sender} to @${receiver}! üéâ\n\n> ${kudosComment}${attribution}`
                    });

                    // Try to send to BLT API (optional, won't fail if user doesn't have profile)
                    try {
                        await axios.post('https://owaspblt.org/teams/give-kudos/', {
                            kudosReceiver: receiver,
                            kudosSender: sender,
                            link: link,
                            comment: kudosComment
                        });

                        // If successful, add a follow-up comment about BLT tracking
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issueNumber,
                            body: `‚úÖ Kudos tracked on [BLT profile](https://owaspblt.org/profile/${receiver})!${attribution}`
                        });
                        
                        console.log(`Kudos successfully tracked on BLT for ${receiver}`);
                    } catch (apiError) {
                        console.log(`Note: Kudos not tracked on BLT (user may not have a profile): ${apiError.message}`);
                        
                        // Post informational message about BLT profile (only if it's a 404 or similar)
                        if (apiError.response && (apiError.response.status === 404 || apiError.response.status === 400)) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issueNumber,
                                body: `üí° @${receiver} - Create a [BLT profile](https://owaspblt.org) to track all your kudos in one place!${attribution}`
                            });
                        }
                    }
                } else {
                    console.log('Invalid /kudos command format.');
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `‚ö†Ô∏è Invalid /kudos command format.\n\nUsage: \`/kudos @username [optional comment]\`\n\nExample: \`/kudos @alice Great work on the PR!\`${attribution}`
                    });
                }
            } else if (shouldTip) {
                const tipCommand = comment.body.trim().split(/\s+/);
                if (tipCommand.length >= 3) {
                    const sender = comment.user.login; // GitHub username of the commenter
                    const receiver = tipCommand[1].replace('@', ''); // Remove @ if present
                    const amount = tipCommand[2]; // Amount with $ symbol

                    // Validate amount format
                    const amountMatch = amount.match(/^\$?(\d+(?:\.\d{1,2})?)$/);
                    if (!amountMatch) {
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issue ? issue.number : pull_request.number,
                            body: `‚ö†Ô∏è Invalid amount format. Use: \`/tip @username $amount\` (e.g., \`/tip @user $5\` or \`/tip @user $10.50\`)${attribution}`
                        });
                        return;
                    }

                    const amountValue = parseFloat(amountMatch[1]);

                    console.log(`Processing automated tip from ${sender} to ${receiver} for $${amountValue}`);

                    try {
                        // Step 1: Get user's sponsorable ID and available tiers using GitHub GraphQL API
                        const graphqlUrl = 'https://api.github.com/graphql';
                        const queryUser = `
                            query($login: String!) {
                                user(login: $login) {
                                    id
                                    sponsorsListing {
                                        id
                                        tiers(first: 20) {
                                            nodes {
                                                id
                                                monthlyPriceInCents
                                                name
                                            }
                                        }
                                    }
                                }
                            }
                        `;

                        const userResponse = await axios.post(graphqlUrl, {
                            query: queryUser,
                            variables: { login: receiver }
                        }, {
                            headers: {
                                'Authorization': `Bearer ${gitHubToken}`,
                                'Content-Type': 'application/json'
                            }
                        });

                        if (userResponse.data.errors) {
                            console.error('GraphQL errors:', userResponse.data.errors);
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è @${receiver} does not appear to have GitHub Sponsors enabled. Please verify the username or ask them to set up GitHub Sponsors first.\n\nLearn more: https://github.com/sponsors${attribution}`
                            });
                            return;
                        }

                        const userInfo = userResponse.data.data?.user;
                        const sponsorableId = userInfo?.id;
                        const sponsorsListing = userInfo?.sponsorsListing;

                        if (!sponsorableId || !sponsorsListing) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è @${receiver} does not have GitHub Sponsors enabled. Please ask them to set up GitHub Sponsors first.\n\nLearn more: https://github.com/sponsors${attribution}`
                            });
                            return;
                        }

                        // Step 2: Find exact matching tier only (no rounding up)
                        const tiers = sponsorsListing.tiers?.nodes || [];
                        const targetAmountCents = Math.round(amountValue * 100);

                        const matchingTier = tiers.find(tier => tier.monthlyPriceInCents === targetAmountCents);

                        if (!matchingTier) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è No sponsorship tier found matching $${amountValue}. @${receiver} needs to create a tier with this exact amount.\n\nAvailable tiers: ${tiers.map(t => `$${(t.monthlyPriceInCents / 100).toFixed(2)}`).join(', ') || 'None'}\n\nLearn more: https://github.com/sponsors/${receiver}/sponsorships${attribution}`
                            });
                            return;
                        }

                        const tierId = matchingTier.id;

                        // Step 3: Create sponsorship
                        const createMutation = `
                            mutation($sponsorableId: ID!, $tierId: ID!) {
                                createSponsorship(input: {
                                    sponsorableId: $sponsorableId
                                    tierId: $tierId
                                    privacyLevel: PUBLIC
                                }) {
                                    sponsorship {
                                        id
                                        tier {
                                            monthlyPriceInCents
                                            name
                                        }
                                        createdAt
                                    }
                                }
                            }
                        `;

                        const createResponse = await axios.post(graphqlUrl, {
                            query: createMutation,
                            variables: {
                                sponsorableId: sponsorableId,
                                tierId: tierId
                            }
                        }, {
                            headers: {
                                'Authorization': `Bearer ${gitHubToken}`,
                                'Content-Type': 'application/json'
                            }
                        });

                        if (createResponse.data.errors) {
                            console.error('GraphQL errors creating sponsorship:', createResponse.data.errors);
                            const errorMessages = createResponse.data.errors.map(err => err.message).join('; ');
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è Failed to create sponsorship: ${errorMessages}\n\nPlease try again later or visit https://github.com/sponsors/${receiver} to sponsor manually.${attribution}`
                            });
                            return;
                        }

                        const sponsorshipData = createResponse.data.data?.createSponsorship?.sponsorship;
                        const sponsorshipId = sponsorshipData?.id;

                        if (!sponsorshipId) {
                            console.error('No sponsorship ID in response:', createResponse.data);
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è Failed to create sponsorship. Please ensure @${receiver} has GitHub Sponsors enabled.\n\nVisit: https://github.com/sponsors/${receiver}${attribution}`
                            });
                            return;
                        }

                        console.log(`Successfully created sponsorship: ${sponsorshipId}`);

                        // Step 4: IMMEDIATELY cancel the sponsorship to prevent recurring charges
                        const cancelMutation = `
                            mutation($sponsorshipId: ID!) {
                                cancelSponsorship(input: {
                                    sponsorshipId: $sponsorshipId
                                }) {
                                    sponsorsTier {
                                        monthlyPriceInCents
                                        name
                                    }
                                }
                            }
                        `;

                        // Attempt to cancel with retries
                        let cancelSuccess = false;
                        const maxRetries = 3;

                        for (let attempt = 0; attempt < maxRetries; attempt++) {
                            try {
                                console.log(`Attempting to cancel sponsorship ${sponsorshipId} (attempt ${attempt + 1}/${maxRetries})`);

                                const cancelResponse = await axios.post(graphqlUrl, {
                                    query: cancelMutation,
                                    variables: { sponsorshipId: sponsorshipId }
                                }, {
                                    headers: {
                                        'Authorization': `Bearer ${gitHubToken}`,
                                        'Content-Type': 'application/json'
                                    }
                                });

                                if (!cancelResponse.data.errors) {
                                    console.log(`Successfully cancelled sponsorship ${sponsorshipId}`);
                                    cancelSuccess = true;
                                    break;
                                } else {
                                    console.error(`GraphQL errors cancelling sponsorship: ${JSON.stringify(cancelResponse.data.errors)}`);
                                }

                                // Wait before retry (exponential backoff)
                                if (attempt < maxRetries - 1) {
                                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                                }
                            } catch (cancelError) {
                                console.error('Network error cancelling sponsorship:', cancelError.message);
                                if (attempt < maxRetries - 1) {
                                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                                }
                            }
                        }

                        // Post success or warning message
                        if (cancelSuccess) {
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚úÖ **Tip Sent Successfully!**\n\n` +
                                    `@${sender} sent **$${amountValue}** to @${receiver} via GitHub Sponsors! üéâ\n\n` +
                                    `Transaction ID: \`${sponsorshipId}\`\n\n` +
                                    `*This was a one-time payment processed automatically.*${attribution}`
                            });
                        } else {
                            // CRITICAL: Cancellation failed - alert about recurring charge
                            console.error(`CRITICAL: Failed to cancel sponsorship ${sponsorshipId} after ${maxRetries} attempts`);
                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: issue ? issue.number : pull_request.number,
                                body: `‚ö†Ô∏è **URGENT: Manual Action Required**\n\n` +
                                    `A tip of **$${amountValue}** was initiated from @${sender} to @${receiver}, but automatic cancellation failed.\n\n` +
                                    `**This means recurring charges will continue monthly!**\n\n` +
                                    `Transaction ID: \`${sponsorshipId}\`\n\n` +
                                    `Please immediately cancel this sponsorship manually at:\n` +
                                    `üîó https://github.com/sponsors/${receiver}\n\n` +
                                    `Repository maintainers have been notified.${attribution}`
                            });
                        }
                    } catch (error) {
                        console.error('Error processing automated tip:', error);
                        await octokit.issues.createComment({
                            owner,
                            repo: repoName,
                            issue_number: issue ? issue.number : pull_request.number,
                            body: `‚ö†Ô∏è Failed to process automated tip. Please try again later or visit https://github.com/sponsors/${receiver} to sponsor manually.\n\nError: ${error.message}${attribution}`
                        });
                    }
                } else {
                    console.log('Invalid /tip command format.');
                    await octokit.issues.createComment({
                        owner,
                        repo: repoName,
                        issue_number: issue ? issue.number : pull_request.number,
                        body: `‚ö†Ô∏è Invalid /tip command format. Use: \`/tip @username $amount\`\n\nExample: \`/tip @contributor $10\`${attribution}`
                    });
                }
            }
        }

        console.log('Checking for stale assignments...');
        const presentDate = new Date();

        try {
            const events = await octokit.paginate(octokit.issues.listEventsForRepo, {
                owner,
                repo: repoName,
                per_page: 100,
            }, response => response.data.filter(event => event.event === "assigned"));

            for (const event of events) {
                if (event.issue.assignee && event.issue.state === "open") {
                    const timeSinceUpdate = presentDate.getTime() - new Date(event.issue.updated_at).getTime();
                    const daysInactive = timeSinceUpdate / (1000 * 3600 * 24);

                    if (daysInactive > 1) {
                        console.log(`Unassigning issue #${event.issue.number} due to inactivity`);
                        try {
                            const timelineEvents = await octokit.paginate(octokit.issues.listEventsForTimeline, {
                                owner,
                                repo: repoName,
                                issue_number: event.issue.number,
                                per_page: 100,
                            });

                            const hasOpenLinkedPR = timelineEvents.some(e =>
                                e.event === "cross-referenced" &&
                                e.source &&
                                e.source.issue &&
                                e.source.issue.pull_request &&
                                e.source.issue.state === "open"
                            );
                            if (hasOpenLinkedPR) {
                                console.log(`Issue #${event.issue.number} has an open pull request (cross-referenced), skipping unassign.`);
                                continue;
                            }
                        } catch (searchError) {
                            console.log(`Error checking for open pull requests for issue #${event.issue.number}:`, searchError);
                            console.log(`Skipping unassignment for issue #${event.issue.number} due to verification failure.`);
                            continue;
                        }

                        const issueDetails = await octokit.issues.get({
                            owner,
                            repo: repoName,
                            issue_number: event.issue.number
                        });

                        const hasAssignedLabel = issueDetails.data.labels.some(label => label.name === "assigned");

                        if (hasAssignedLabel) {
                            await octokit.issues.removeAssignees({
                                owner,
                                repo: repoName,
                                issue_number: event.issue.number,
                                assignees: [event.issue.assignee.login]
                            });

                            await octokit.issues.removeLabel({
                                owner,
                                repo: repoName,
                                issue_number: event.issue.number,
                                name: "assigned"
                            });

                            await octokit.issues.createComment({
                                owner,
                                repo: repoName,
                                issue_number: event.issue.number,
                                body: `‚è∞ This issue has been automatically unassigned from ${event.issue.assignee.login} due to 24 hours of inactivity. The issue is now available for anyone to work on again.${attribution}`
                            });
                        } else {
                            console.log(`Issue #${event.issue.number} does not have the "assigned" label, skipping unassign.`);
                        }
                    }
                }
            }
        } catch (error) {
            console.error("Error processing stale assignments:", error);
        }

    } catch (error) {
        console.error("Critical error in GitHub Action:", error);
    }
};

run();
