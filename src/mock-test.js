const nock = require('nock');
const assert = require('assert');
const axios = require('axios');

const attribution = '\n\n---\n*This comment was generated by [OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)*';

async function assignUserToIssue(owner, repo, issueNumber, username) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`;
  const response = await axios.post(url, { assignees: [username] });
  return response.data;
}

async function unassignUserFromIssue(owner, repo, issueNumber, username) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`;
  const response = await axios.delete(url, { data: { assignees: [username] } });
  return response.data;
}

async function addLabelToIssue(owner, repo, issueNumber, labels) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/labels`;
  const response = await axios.post(url, { labels });
  return response.data;
}

async function removeLabelFromIssue(owner, repo, issueNumber, labelName) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/labels/${labelName}`;
  const response = await axios.delete(url);
  return response.data;
}

async function postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey) {
  const giphyResponse = await axios.get(`https://api.giphy.com/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`);
  const gifUrl = giphyResponse.data.data[0]?.images?.original?.url;

  if (gifUrl) {
    const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;
    const response = await axios.post(url, { body: `![Giphy GIF](${gifUrl})` });
    return response.data;
  } else {
    throw new Error(`No GIFs found for "${searchText}".`);
  }
}

async function postTipComment(owner, repo, issueNumber, receiver, amount) {
  const sponsorUrl = `https://github.com/sponsors/${receiver}`;
  
  // Check if GitHub Sponsors is enabled
  await axios.head(sponsorUrl);
  
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;
  const response = await axios.post(url, {
    body: `ðŸ’° **Tip Request from @sender to @${receiver}**\n\nAmount: **$${amount}**\n\nTo complete this tip, please visit @${receiver}'s GitHub Sponsors page and select a one-time payment:\n\nðŸ”— [Sponsor @${receiver}](${sponsorUrl})\n\n*Note: GitHub Sponsors does not support automated payments via API. Please complete the transaction manually by selecting "One-time" on the sponsor page and entering your desired amount.*`
  });
  return response.data;
}

async function sendKudos(sender, receiver, comment, link) {
  const response = await axios.post('https://owaspblt.org/teams/give-kudos/', {
    kudosReceiver: receiver,
    kudosSender: sender,
    link: link,
    comment: comment
  });
  return response.data;
}

describe('GitHub API Mock Test', () => {
  beforeEach(() => {
    nock.cleanAll();
  });

  describe('Assignment Management', () => {
    it('should assign a user to an issue with a PR', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const username = 'testuser';

      const scope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/assignees`, { assignees: [username] })
        .reply(201, { status: 'success' });

      const result = await assignUserToIssue(owner, repo, issueNumber, username);
      assert.strictEqual(result.status, 'success');

      scope.done();
    });

    it('should unassign a user from an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const username = 'testuser';

      const scope = nock('https://api.github.com')
        .delete(`/repos/${owner}/${repo}/issues/${issueNumber}/assignees`, { assignees: [username] })
        .reply(200, { status: 'success' });

      const result = await unassignUserFromIssue(owner, repo, issueNumber, username);
      assert.strictEqual(result.status, 'success');

      scope.done();
    });

    it('should detect all assignment keywords', () => {
      const assignKeywords = [
        '/assign',
        'assign to me',
        'assign this to me',
        'assign it to me',
        'assign me this',
        'work on this',
        'i can try fixing this',
        'i am interested in doing this',
        'be assigned this',
        'i am interested in contributing'
      ];

      assignKeywords.forEach(keyword => {
        const testComment = `I would like to ${keyword}`.toLowerCase();
        assert.ok(
          assignKeywords.some(k => testComment.includes(k)),
          `Keyword "${keyword}" should be detected in comment`
        );
      });
    });
  });

  describe('Label Management', () => {
    it('should add "assigned" label to an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;

      const scope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/labels`, { labels: ['assigned'] })
        .reply(200, { status: 'success' });

      const result = await addLabelToIssue(owner, repo, issueNumber, ['assigned']);
      assert.strictEqual(result.status, 'success');

      scope.done();
    });

    it('should remove "assigned" label from an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;

      const scope = nock('https://api.github.com')
        .delete(`/repos/${owner}/${repo}/issues/${issueNumber}/labels/assigned`)
        .reply(200, { status: 'success' });

      const result = await removeLabelFromIssue(owner, repo, issueNumber, 'assigned');
      assert.strictEqual(result.status, 'success');

      scope.done();
    });
  });

  describe('Giphy Integration', () => {
    it('should post a Giphy comment on an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const searchText = 'funny cat';
      const giphyApiKey = 'testapikey';

      const giphyScope = nock('https://api.giphy.com')
        .get(`/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`)
        .reply(200, {
          data: [
            {
              images: {
                original: {
                  url: 'https://giphy.com/gifs/moodman-dog-confused-rigley-beans-Z5xk7fGO5FjjTElnpT'
                }
              }
            }
          ]
        });

      const githubScope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, { body: '![Giphy GIF](https://giphy.com/gifs/moodman-dog-confused-rigley-beans-Z5xk7fGO5FjjTElnpT)' })
        .reply(201, { status: 'success' });

      const result = await postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey);
      assert.strictEqual(result.status, 'success');

      giphyScope.done();
      githubScope.done();
    });

    it('should handle no GIFs found scenario', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const searchText = 'nonexistentgif12345';
      const giphyApiKey = 'testapikey';

      const giphyScope = nock('https://api.giphy.com')
        .get(`/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`)
        .reply(200, {
          data: []
        });

      try {
        await postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('No GIFs found'));
      }

      giphyScope.done();
    });
  });

  it('should post a tip comment with GitHub Sponsors link', async () => {
    const owner = 'testowner';
    const repo = 'testrepo';
    const issueNumber = 1;
    const receiver = 'testuser';
    const amount = '10';

    // Mock the HEAD request to check if sponsors page exists
    const sponsorScope = nock('https://github.com')
      .head(`/sponsors/${receiver}`)
      .reply(200);

    const githubScope = nock('https://api.github.com')
      .post(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, (body) => {
        return body.body.includes('Tip Request') && 
               body.body.includes(`@${receiver}`) && 
               body.body.includes(`$${amount}`) &&
               body.body.includes(`https://github.com/sponsors/${receiver}`);
      })
      .reply(201, { status: 'success' });

    const result = await postTipComment(owner, repo, issueNumber, receiver, amount);
    assert.strictEqual(result.status, 'success');

    sponsorScope.done();
    githubScope.done();
  });

  describe('Kudos System', () => {
    it('should send kudos to BLT API when user has profile', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const sender = 'githubuser';
      const receiver = 'bltuser';
      const comment = 'Great work on the PR!';
      const link = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;

      const bltScope = nock('https://owaspblt.org')
        .post('/teams/give-kudos/', {
          kudosReceiver: receiver,
          kudosSender: sender,
          link: link,
          comment: comment
        })
        .reply(201, { success: true, message: 'Kudos sent successfully!' });

      const result = await sendKudos(sender, receiver, comment, link);
      assert.strictEqual(result.success, true);

      bltScope.done();
    });

    it('should handle kudos when user does not have BLT profile', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const sender = 'githubuser';
      const receiver = 'newuser';
      const comment = 'Great work on the PR!';
      const link = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;

      const bltScope = nock('https://owaspblt.org')
        .post('/teams/give-kudos/', {
          kudosReceiver: receiver,
          kudosSender: sender,
          link: link,
          comment: comment
        })
        .reply(404, { success: false, error: 'Receiver username not found' });

      try {
        await sendKudos(sender, receiver, comment, link);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.strictEqual(error.response.status, 404);
      }

      bltScope.done();
    });
  });

  describe('Command Detection', () => {
    it('should detect /unassign command', () => {
      const testComments = [
        '/unassign',
        '/unassign me',
        '/unassign please'
      ];

      testComments.forEach(comment => {
        assert.ok(
          comment.toLowerCase().startsWith('/unassign'),
          `Command "${comment}" should be detected as /unassign`
        );
      });
    });

    it('should detect /giphy command', () => {
      const testComments = [
        '/giphy celebration',
        '/giphy funny cat',
        '/giphy winning'
      ];

      testComments.forEach(comment => {
        assert.ok(
          comment.toLowerCase().startsWith('/giphy'),
          `Command "${comment}" should be detected as /giphy`
        );
      });
    });

    it('should detect /kudos command', () => {
      const testComments = [
        '/kudos @user great work',
        '/kudos @contributor awesome',
        '/kudos @dev'
      ];

      testComments.forEach(comment => {
        assert.ok(
          comment.toLowerCase().startsWith('/kudos'),
          `Command "${comment}" should be detected as /kudos`
        );
      });
    });
  });

  describe('Attribution', () => {
    it('should include attribution in comment bodies', () => {
      // Test various comment bodies to ensure they include the attribution
      const testComments = [
        'You have been unassigned from this issue. It\'s now open for others. You can reassign it anytime by typing /assign.',
        'You cannot be assigned to this issue because you are already assigned to the following issues without an open pull request: #1. Please submit a pull request for these issues before getting assigned to a new one.',
        'Hello @user! You\'ve been assigned to [repo issue #1](https://github.com/owner/repo/issues/1). You have 24 hours to complete a pull request.',
        'No GIFs found for "test".',
        'ðŸŽ‰ Kudos from @sender to @receiver! ðŸŽ‰\n\nawesome work',
        'âœ… Kudos tracked on BLT profile',
        'ðŸ’¡ @receiver - Create a BLT profile to track all your kudos in one place!',
        'âš ï¸ Invalid /kudos command format.\n\nUsage: `/kudos @username [optional comment]`\n\nExample: `/kudos @alice Great work on the PR!`',
        'â° This issue has been automatically unassigned from user due to 24 hours of inactivity. The issue is now available for anyone to work on again.',
        'ðŸ’° **Tip Request from @sender to @receiver**\n\nAmount: **$10**\n\nTo complete this tip, please visit @receiver\'s GitHub Sponsors page and select a one-time payment:\n\nðŸ”— [Sponsor @receiver](https://github.com/sponsors/receiver)\n\n*Note: GitHub Sponsors does not support automated payments via API. Please complete the transaction manually by selecting "One-time" on the sponsor page and entering your desired amount.*',
        'âš ï¸ Invalid /tip command format. Use: `/tip @username $amount`\n\nExample: `/tip @contributor $10`'
      ];

      // Each comment should end with the attribution
      testComments.forEach((comment, index) => {
        const commentWithAttribution = comment + attribution;
        const expectedLink = '[OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)';
        assert.ok(
          commentWithAttribution.includes('OWASP BLT-Action'),
          `Comment ${index + 1} should include attribution`
        );
        assert.ok(
          commentWithAttribution.includes(expectedLink),
          `Comment ${index + 1} should include the exact attribution link format`
        );
      });
    });

    it('should have consistent attribution format', () => {
      const expectedAttribution = '\n\n---\n*This comment was generated by [OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)*';
      assert.strictEqual(attribution, expectedAttribution, 'Attribution format should be consistent');
    });
  });

  describe('Error Handling', () => {
    it('should handle GitHub API errors gracefully', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const username = 'testuser';

      const scope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/assignees`, { assignees: [username] })
        .reply(500, { message: 'Internal Server Error' });

      try {
        await assignUserToIssue(owner, repo, issueNumber, username);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('500'));
      }

      scope.done();
    });

    it('should handle Giphy API errors gracefully', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const searchText = 'test';
      const giphyApiKey = 'testapikey';

      const giphyScope = nock('https://api.giphy.com')
        .get(`/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`)
        .reply(403, { message: 'Forbidden' });

      try {
        await postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('403'));
      }

      giphyScope.done();
    });

    it('should handle Kudos API errors gracefully', async () => {
      const sender = 'testsender';
      const receiver = '@testreceiver';
      const comment = 'great work';
      const link = 'https://github.com/owner/repo/issues/1';

      const scope = nock('https://owaspblt.org')
        .post('/teams/give-kudos/', {
          kudosReceiver: receiver,
          kudosSender: sender,
          link: link,
          comment: comment
        })
        .reply(500, { message: 'Internal Server Error' });

      try {
        await sendKudos(sender, receiver, comment, link);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('500'));
      }

      scope.done();
    });
  });
  describe('Human commenter guard for /assign and /unassign', () => {
    // Mirror the production logic in src/index.js
    function isHumanCommenter(comment) {
      return (
        comment &&
        comment.user &&
        comment.user.type === 'User'
      );
    }

    it('treats normal GitHub users as human commenters', () => {
      const humanAssignComment = {
        body: '/assign',
        user: { login: 'alice', type: 'User' },
      };

      const humanUnassignComment = {
        body: '/unassign',
        user: { login: 'alice', type: 'User' },
      };

      assert.strictEqual(isHumanCommenter(humanAssignComment), true);
      assert.strictEqual(isHumanCommenter(humanUnassignComment), true);
    });

    it('treats bots and GitHub Apps as non-human commenters', () => {
      const botComment = {
        body: '/assign',
        user: { login: 'coderabbitai', type: 'Bot' },
      };

      const appComment = {
        body: '/unassign',
        user: { login: 'some-app[bot]', type: 'App' },
      };

      assert.strictEqual(isHumanCommenter(botComment), false);
      assert.strictEqual(isHumanCommenter(appComment), false);
    });

    it('does not allow bots to trigger /assign or /unassign commands', () => {
      const botAssignComment = {
        body: '/assign',
        user: { login: 'coderabbitai', type: 'Bot' },
      };

      const botUnassignComment = {
        body: '/unassign',
        user: { login: 'coderabbitai', type: 'Bot' },
      };

      const assignBody = (botAssignComment.body || '').toLowerCase();
      const unassignBody = (botUnassignComment.body || '').toLowerCase();

      const shouldAssign = assignBody.startsWith('/assign');
      const shouldUnassign = unassignBody.startsWith('/unassign');

      // Commands are presentâ€¦
      assert.strictEqual(shouldAssign, true);
      assert.strictEqual(shouldUnassign, true);

      // â€¦but the human guard blocks them.
      assert.strictEqual(isHumanCommenter(botAssignComment), false);
      assert.strictEqual(isHumanCommenter(botUnassignComment), false);
    });

    it('allows human users to trigger /assign and /unassign commands', () => {
      const humanAssignComment = {
        body: '/assign',
        user: { login: 'alice', type: 'User' },
      };

      const humanUnassignComment = {
        body: '/unassign',
        user: { login: 'alice', type: 'User' },
      };

      const assignBody = (humanAssignComment.body || '').toLowerCase();
      const unassignBody = (humanUnassignComment.body || '').toLowerCase();

      const shouldAssign = assignBody.startsWith('/assign');
      const shouldUnassign = unassignBody.startsWith('/unassign');

      assert.strictEqual(shouldAssign, true);
      assert.strictEqual(shouldUnassign, true);
      assert.strictEqual(isHumanCommenter(humanAssignComment), true);
      assert.strictEqual(isHumanCommenter(humanUnassignComment), true);
    });
  });
});