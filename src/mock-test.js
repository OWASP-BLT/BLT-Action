const nock = require('nock');
const assert = require('assert');
const axios = require('axios');

const attribution = '\n\n---\n*This comment was generated by [OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)*';

async function assignUserToIssue(owner, repo, issueNumber, username) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`;
  const response = await axios.post(url, { assignees: [username] });
  return response.data;
}

async function unassignUserFromIssue(owner, repo, issueNumber, username) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`;
  const response = await axios.delete(url, { data: { assignees: [username] } });
  return response.data;
}

async function addLabelToIssue(owner, repo, issueNumber, labels) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/labels`;
  const response = await axios.post(url, { labels });
  return response.data;
}

async function removeLabelFromIssue(owner, repo, issueNumber, labelName) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/labels/${labelName}`;
  const response = await axios.delete(url);
  return response.data;
}

async function postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey) {
  const giphyResponse = await axios.get(`https://api.giphy.com/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`);
  const gifUrl = giphyResponse.data.data[0]?.images?.original?.url;

  if (gifUrl) {
    const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;
    const response = await axios.post(url, { body: `![Giphy GIF](${gifUrl})` });
    return response.data;
  } else {
    throw new Error(`No GIFs found for "${searchText}".`);
  }
}

async function processAutomatedTip(owner, repo, issueNumber, sender, receiver, amount, gitHubToken) {
  const graphqlUrl = 'https://api.github.com/graphql';
  
  // Step 1: Get user's sponsorable ID and tiers
  const queryUser = `
    query($login: String!) {
      user(login: $login) {
        id
        sponsorsListing {
          id
          tiers(first: 20) {
            nodes {
              id
              monthlyPriceInCents
              name
            }
          }
        }
      }
    }
  `;
  
  const userResponse = await axios.post(graphqlUrl, {
    query: queryUser,
    variables: { login: receiver }
  }, {
    headers: {
      'Authorization': `Bearer ${gitHubToken}`,
      'Content-Type': 'application/json'
    }
  });
  
  if (userResponse.data.errors) {
    const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;
    await axios.post(url, {
      body: `‚ö†Ô∏è @${receiver} does not appear to have GitHub Sponsors enabled.`
    });
    return { status: 'success' };
  }
  
  const userInfo = userResponse.data.data?.user;
  const sponsorableId = userInfo?.id;
  const sponsorsListing = userInfo?.sponsorsListing;
  
  if (!sponsorableId || !sponsorsListing) {
    const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;
    await axios.post(url, {
      body: `‚ö†Ô∏è @${receiver} does not have GitHub Sponsors enabled.`
    });
    return { status: 'success' };
  }
  
  // Step 2: Find matching tier
  const tiers = sponsorsListing.tiers?.nodes || [];
  const targetAmountCents = Math.round(amount * 100);
  const matchingTier = tiers.find(tier => tier.monthlyPriceInCents === targetAmountCents);
  
  if (!matchingTier) {
    const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;
    await axios.post(url, {
      body: `‚ö†Ô∏è No sponsorship tier found matching $${amount}.`
    });
    return { status: 'success' };
  }
  
  // Step 3: Create sponsorship
  const createMutation = `
    mutation($sponsorableId: ID!, $tierId: ID!) {
      createSponsorship(input: {
        sponsorableId: $sponsorableId
        tierId: $tierId
        privacyLevel: PUBLIC
      }) {
        sponsorship {
          id
          tier {
            monthlyPriceInCents
            name
          }
          createdAt
        }
      }
    }
  `;
  
  const createResponse = await axios.post(graphqlUrl, {
    query: createMutation,
    variables: {
      sponsorableId: sponsorableId,
      tierId: matchingTier.id
    }
  }, {
    headers: {
      'Authorization': `Bearer ${gitHubToken}`,
      'Content-Type': 'application/json'
    }
  });
  
  const sponsorshipId = createResponse.data.data?.createSponsorship?.sponsorship?.id;
  
  // Step 4: Cancel sponsorship
  const cancelMutation = `
    mutation($sponsorshipId: ID!) {
      cancelSponsorship(input: {
        sponsorshipId: $sponsorshipId
      }) {
        sponsorsTier {
          monthlyPriceInCents
          name
        }
      }
    }
  `;
  
  let cancelSuccess = false;
  for (let attempt = 0; attempt < 3; attempt++) {
    const cancelResponse = await axios.post(graphqlUrl, {
      query: cancelMutation,
      variables: { sponsorshipId: sponsorshipId }
    }, {
      headers: {
        'Authorization': `Bearer ${gitHubToken}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (!cancelResponse.data.errors) {
      cancelSuccess = true;
      break;
    }
  }
  
  // Post result comment
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/comments`;
  if (cancelSuccess) {
    await axios.post(url, {
      body: `‚úÖ **Tip Sent Successfully!**\n\n@${sender} sent **$${amount}** to @${receiver} via GitHub Sponsors! üéâ\n\nTransaction ID: \`${sponsorshipId}\``
    });
  } else {
    await axios.post(url, {
      body: `‚ö†Ô∏è **URGENT: Manual Action Required**\n\nA tip of **$${amount}** was initiated from @${sender} to @${receiver}, but automatic cancellation failed.\n\n**This means recurring charges will continue monthly!**`
    });
  }
  
  return { status: 'success' };
}

async function sendKudos(sender, receiver, comment, link) {
  const response = await axios.post('https://owaspblt.org/teams/give-kudos/', {
    kudosReceiver: receiver,
    kudosSender: sender,
    link: link,
    comment: comment
  });
  return response.data;
}

describe('GitHub API Mock Test', () => {
  beforeEach(() => {
    nock.cleanAll();
  });

  describe('Assignment Management', () => {
    it('should assign a user to an issue with a PR', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const username = 'testuser';

      const scope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/assignees`, { assignees: [username] })
        .reply(201, { status: 'success' });

      const result = await assignUserToIssue(owner, repo, issueNumber, username);
      assert.strictEqual(result.status, 'success');

      scope.done();
    });

    it('should unassign a user from an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const username = 'testuser';

      const scope = nock('https://api.github.com')
        .delete(`/repos/${owner}/${repo}/issues/${issueNumber}/assignees`, { assignees: [username] })
        .reply(200, { status: 'success' });

      const result = await unassignUserFromIssue(owner, repo, issueNumber, username);
      assert.strictEqual(result.status, 'success');

      scope.done();
    });

    it('should detect all assignment keywords', () => {
      const assignKeywords = [
        '/assign',
        'assign to me',
        'assign this to me',
        'assign it to me',
        'assign me this',
        'work on this',
        'i can try fixing this',
        'i am interested in doing this',
        'be assigned this',
        'i am interested in contributing'
      ];

      assignKeywords.forEach(keyword => {
        const testComment = `I would like to ${keyword}`.toLowerCase();
        assert.ok(
          assignKeywords.some(k => testComment.includes(k)),
          `Keyword "${keyword}" should be detected in comment`
        );
      });
    });
  });

  describe('Label Management', () => {
    it('should add "assigned" label to an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;

      const scope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/labels`, { labels: ['assigned'] })
        .reply(200, { status: 'success' });

      const result = await addLabelToIssue(owner, repo, issueNumber, ['assigned']);
      assert.strictEqual(result.status, 'success');

      scope.done();
    });

    it('should remove "assigned" label from an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;

      const scope = nock('https://api.github.com')
        .delete(`/repos/${owner}/${repo}/issues/${issueNumber}/labels/assigned`)
        .reply(200, { status: 'success' });

      const result = await removeLabelFromIssue(owner, repo, issueNumber, 'assigned');
      assert.strictEqual(result.status, 'success');

      scope.done();
    });
  });

  describe('Giphy Integration', () => {
    it('should post a Giphy comment on an issue', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const searchText = 'funny cat';
      const giphyApiKey = 'testapikey';

      const giphyScope = nock('https://api.giphy.com')
        .get(`/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`)
        .reply(200, {
          data: [
            {
              images: {
                original: {
                  url: 'https://giphy.com/gifs/moodman-dog-confused-rigley-beans-Z5xk7fGO5FjjTElnpT'
                }
              }
            }
          ]
        });

      const githubScope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, { body: '![Giphy GIF](https://giphy.com/gifs/moodman-dog-confused-rigley-beans-Z5xk7fGO5FjjTElnpT)' })
        .reply(201, { status: 'success' });

      const result = await postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey);
      assert.strictEqual(result.status, 'success');

      giphyScope.done();
      githubScope.done();
    });

    it('should handle no GIFs found scenario', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const searchText = 'nonexistentgif12345';
      const giphyApiKey = 'testapikey';

      const giphyScope = nock('https://api.giphy.com')
        .get(`/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`)
        .reply(200, {
          data: []
        });

      try {
        await postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('No GIFs found'));
      }

      giphyScope.done();
    });
  });

  describe('Tip System with Auto-Payment', () => {
    it('should successfully create and cancel sponsorship for automated tip', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const receiver = 'testuser';
      const amount = 10;
      const gitHubToken = 'test-token';

      // Mock GraphQL query for user info
      const graphqlScope1 = nock('https://api.github.com')
        .post('/graphql', (body) => {
          return body.query.includes('user(login: $login)');
        })
        .reply(200, {
          data: {
            user: {
              id: 'user-id-123',
              sponsorsListing: {
                id: 'listing-id-456',
                tiers: {
                  nodes: [
                    { id: 'tier-id-10', monthlyPriceInCents: 1000, name: '$10 tier' },
                    { id: 'tier-id-20', monthlyPriceInCents: 2000, name: '$20 tier' }
                  ]
                }
              }
            }
          }
        });

      // Mock GraphQL mutation for creating sponsorship
      const graphqlScope2 = nock('https://api.github.com')
        .post('/graphql', (body) => {
          return body.query.includes('createSponsorship');
        })
        .reply(200, {
          data: {
            createSponsorship: {
              sponsorship: {
                id: 'sponsorship-id-789',
                tier: {
                  monthlyPriceInCents: 1000,
                  name: '$10 tier'
                },
                createdAt: '2023-01-01T00:00:00Z'
              }
            }
          }
        });

      // Mock GraphQL mutation for cancelling sponsorship
      const graphqlScope3 = nock('https://api.github.com')
        .post('/graphql', (body) => {
          return body.query.includes('cancelSponsorship');
        })
        .reply(200, {
          data: {
            cancelSponsorship: {
              sponsorsTier: {
                monthlyPriceInCents: 1000,
                name: '$10 tier'
              }
            }
          }
        });

      // Mock GitHub comment for success
      const githubScope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, (body) => {
          return body.body.includes('Tip Sent Successfully') && 
                 body.body.includes(`$${amount}`) &&
                 body.body.includes('sponsorship-id-789');
        })
        .reply(201, { status: 'success' });

      const result = await processAutomatedTip(owner, repo, issueNumber, 'sender', receiver, amount, gitHubToken);
      assert.strictEqual(result.status, 'success');

      graphqlScope1.done();
      graphqlScope2.done();
      graphqlScope3.done();
      githubScope.done();
    });

    it('should handle user without GitHub Sponsors enabled', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const receiver = 'testuser';
      const amount = 10;
      const gitHubToken = 'test-token';

      // Mock GraphQL query returning error
      const graphqlScope = nock('https://api.github.com')
        .post('/graphql')
        .reply(200, {
          errors: [{ message: 'User not found' }]
        });

      const githubScope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, (body) => {
          return body.body.includes('does not appear to have GitHub Sponsors enabled');
        })
        .reply(201, { status: 'success' });

      const result = await processAutomatedTip(owner, repo, issueNumber, 'sender', receiver, amount, gitHubToken);
      assert.strictEqual(result.status, 'success');

      graphqlScope.done();
      githubScope.done();
    });

    it('should handle no matching tier found', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const receiver = 'testuser';
      const amount = 15; // No matching tier
      const gitHubToken = 'test-token';

      // Mock GraphQL query for user info with different tiers
      const graphqlScope = nock('https://api.github.com')
        .post('/graphql')
        .reply(200, {
          data: {
            user: {
              id: 'user-id-123',
              sponsorsListing: {
                id: 'listing-id-456',
                tiers: {
                  nodes: [
                    { id: 'tier-id-10', monthlyPriceInCents: 1000, name: '$10 tier' },
                    { id: 'tier-id-20', monthlyPriceInCents: 2000, name: '$20 tier' }
                  ]
                }
              }
            }
          }
        });

      const githubScope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, (body) => {
          return body.body.includes('No sponsorship tier found matching');
        })
        .reply(201, { status: 'success' });

      const result = await processAutomatedTip(owner, repo, issueNumber, 'sender', receiver, amount, gitHubToken);
      assert.strictEqual(result.status, 'success');

      graphqlScope.done();
      githubScope.done();
    });

    it('should alert when cancellation fails', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const receiver = 'testuser';
      const amount = 10;
      const gitHubToken = 'test-token';

      // Mock GraphQL query for user info
      const graphqlScope1 = nock('https://api.github.com')
        .post('/graphql', (body) => {
          return body.query.includes('user(login: $login)');
        })
        .reply(200, {
          data: {
            user: {
              id: 'user-id-123',
              sponsorsListing: {
                id: 'listing-id-456',
                tiers: {
                  nodes: [
                    { id: 'tier-id-10', monthlyPriceInCents: 1000, name: '$10 tier' }
                  ]
                }
              }
            }
          }
        });

      // Mock GraphQL mutation for creating sponsorship
      const graphqlScope2 = nock('https://api.github.com')
        .post('/graphql', (body) => {
          return body.query.includes('createSponsorship');
        })
        .reply(200, {
          data: {
            createSponsorship: {
              sponsorship: {
                id: 'sponsorship-id-789',
                tier: {
                  monthlyPriceInCents: 1000,
                  name: '$10 tier'
                },
                createdAt: '2023-01-01T00:00:00Z'
              }
            }
          }
        });

      // Mock GraphQL mutation for cancelling sponsorship (fail multiple times)
      const graphqlScope3 = nock('https://api.github.com')
        .post('/graphql', (body) => {
          return body.query.includes('cancelSponsorship');
        })
        .times(3)
        .reply(200, {
          errors: [{ message: 'Cancellation failed' }]
        });

      // Mock GitHub comment for failure alert
      const githubScope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, (body) => {
          return body.body.includes('URGENT: Manual Action Required') && 
                 body.body.includes('recurring charges will continue');
        })
        .reply(201, { status: 'success' });

      const result = await processAutomatedTip(owner, repo, issueNumber, 'sender', receiver, amount, gitHubToken);
      assert.strictEqual(result.status, 'success');

      graphqlScope1.done();
      graphqlScope2.done();
      graphqlScope3.done();
      githubScope.done();
    });
  });

  describe('Kudos System', () => {
    it('should send kudos to BLT API when user has profile', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const sender = 'githubuser';
      const receiver = 'bltuser';
      const comment = 'Great work on the PR!';
      const link = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;

      const bltScope = nock('https://owaspblt.org')
        .post('/teams/give-kudos/', {
          kudosReceiver: receiver,
          kudosSender: sender,
          link: link,
          comment: comment
        })
        .reply(201, { success: true, message: 'Kudos sent successfully!' });

      const result = await sendKudos(sender, receiver, comment, link);
      assert.strictEqual(result.success, true);

      bltScope.done();
    });

    it('should handle kudos when user does not have BLT profile', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const sender = 'githubuser';
      const receiver = 'newuser';
      const comment = 'Great work on the PR!';
      const link = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;

      const bltScope = nock('https://owaspblt.org')
        .post('/teams/give-kudos/', {
          kudosReceiver: receiver,
          kudosSender: sender,
          link: link,
          comment: comment
        })
        .reply(404, { success: false, error: 'Receiver username not found' });

      try {
        await sendKudos(sender, receiver, comment, link);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.strictEqual(error.response.status, 404);
      }

      bltScope.done();
    });
  });

  describe('Command Detection', () => {
    it('should detect /unassign command', () => {
      const testComments = [
        '/unassign',
        '/unassign me',
        '/unassign please'
      ];

      testComments.forEach(comment => {
        assert.ok(
          comment.toLowerCase().startsWith('/unassign'),
          `Command "${comment}" should be detected as /unassign`
        );
      });
    });

    it('should detect /giphy command', () => {
      const testComments = [
        '/giphy celebration',
        '/giphy funny cat',
        '/giphy winning'
      ];

      testComments.forEach(comment => {
        assert.ok(
          comment.toLowerCase().startsWith('/giphy'),
          `Command "${comment}" should be detected as /giphy`
        );
      });
    });

    it('should detect /kudos command', () => {
      const testComments = [
        '/kudos @user great work',
        '/kudos @contributor awesome',
        '/kudos @dev'
      ];

      testComments.forEach(comment => {
        assert.ok(
          comment.toLowerCase().startsWith('/kudos'),
          `Command "${comment}" should be detected as /kudos`
        );
      });
    });
  });

  describe('Attribution', () => {
    it('should include attribution in comment bodies', () => {
      // Test various comment bodies to ensure they include the attribution
      const testComments = [
        'You have been unassigned from this issue. It\'s now open for others. You can reassign it anytime by typing /assign.',
        'You cannot be assigned to this issue because you are already assigned to the following issues without an open pull request: #1. Please submit a pull request for these issues before getting assigned to a new one.',
        'Hello @user! You\'ve been assigned to [repo issue #1](https://github.com/owner/repo/issues/1). You have 24 hours to complete a pull request.',
        'No GIFs found for "test".',
        'üéâ Kudos from @sender to @receiver! üéâ\n\nawesome work',
        '‚úÖ Kudos tracked on BLT profile',
        'üí° @receiver - Create a BLT profile to track all your kudos in one place!',
        '‚ö†Ô∏è Invalid /kudos command format.\n\nUsage: `/kudos @username [optional comment]`\n\nExample: `/kudos @alice Great work on the PR!`',
        '‚è∞ This issue has been automatically unassigned from user due to 24 hours of inactivity. The issue is now available for anyone to work on again.',
        'üí∞ **Tip Request from @sender to @receiver**\n\nAmount: **$10**\n\nTo complete this tip, please visit @receiver\'s GitHub Sponsors page and select a one-time payment:\n\nüîó [Sponsor @receiver](https://github.com/sponsors/receiver)\n\n*Note: GitHub Sponsors does not support automated payments via API. Please complete the transaction manually by selecting "One-time" on the sponsor page and entering your desired amount.*',
        '‚ö†Ô∏è Invalid /tip command format. Use: `/tip @username $amount`\n\nExample: `/tip @contributor $10`'
      ];

      // Each comment should end with the attribution
      testComments.forEach((comment, index) => {
        const commentWithAttribution = comment + attribution;
        const expectedLink = '[OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)';
        assert.ok(
          commentWithAttribution.includes('OWASP BLT-Action'),
          `Comment ${index + 1} should include attribution`
        );
        assert.ok(
          commentWithAttribution.includes(expectedLink),
          `Comment ${index + 1} should include the exact attribution link format`
        );
      });
    });

    it('should have consistent attribution format', () => {
      const expectedAttribution = '\n\n---\n*This comment was generated by [OWASP BLT-Action](https://github.com/OWASP-BLT/BLT-Action)*';
      assert.strictEqual(attribution, expectedAttribution, 'Attribution format should be consistent');
    });
  });

  describe('Error Handling', () => {
    it('should handle GitHub API errors gracefully', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const username = 'testuser';

      const scope = nock('https://api.github.com')
        .post(`/repos/${owner}/${repo}/issues/${issueNumber}/assignees`, { assignees: [username] })
        .reply(500, { message: 'Internal Server Error' });

      try {
        await assignUserToIssue(owner, repo, issueNumber, username);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('500'));
      }

      scope.done();
    });

    it('should handle Giphy API errors gracefully', async () => {
      const owner = 'testowner';
      const repo = 'testrepo';
      const issueNumber = 1;
      const searchText = 'test';
      const giphyApiKey = 'testapikey';

      const giphyScope = nock('https://api.giphy.com')
        .get(`/v1/gifs/search?api_key=${giphyApiKey}&q=${searchText}&limit=1`)
        .reply(403, { message: 'Forbidden' });

      try {
        await postGiphyComment(owner, repo, issueNumber, searchText, giphyApiKey);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('403'));
      }

      giphyScope.done();
    });

    it('should handle Kudos API errors gracefully', async () => {
      const sender = 'testsender';
      const receiver = '@testreceiver';
      const comment = 'great work';
      const link = 'https://github.com/owner/repo/issues/1';

      const scope = nock('https://owaspblt.org')
        .post('/teams/give-kudos/', {
          kudosReceiver: receiver,
          kudosSender: sender,
          link: link,
          comment: comment
        })
        .reply(500, { message: 'Internal Server Error' });

      try {
        await sendKudos(sender, receiver, comment, link);
        assert.fail('Should have thrown an error');
      } catch (error) {
        assert.ok(error.message.includes('500'));
      }

      scope.done();
    });
  });
});